<!DOCTYPE html>
<meta charset="utf-8">
<meta http-equiv="refresh" content="4">
<style>
	/* Beautiful CSS styling here for now. */

	path {
		stroke: white;
		stroke-width: 0.25px;
		fill: grey;
	}

	.draggable {
		cursor: move;
	}

.arc {
  fill: none;
  stroke: steelblue;
  stroke-width: 1px;
  opacity: .5;
  stroke-linecap: round;
}

</style>
<body>
	<!-- <script src="http://d3js.org/d3.geo.projection.v0.min.js"></script> -->
	<script type="text/javascript" src="js/d3.v3.min.js"></script>
	<script type="text/javascript" src="js/topojson.v1.min.js"></script>

	<script>
		/*Java java */
	var graticule = d3.geo.graticule();
	//Needed? ^
	var width = 960,
		height = 500;

	var projection = d3.geo.equirectangular()
		//.center([0, 5])
		.scale(150)
		//.rotate([-135, -30, 0])
		.translate([width/2, height/2])
		//.clipAngle(90);
		.precision(.1);

	var path = d3.geo.path()
		.projection(projection);

	var λ = d3.scale.linear()
	    .domain([0, width])
	    .range([-180, 180]);

	var φ = d3.scale.linear()
	    .domain([0, height])
	    .range([90, -90]);

	var drag = d3.behavior.drag()
		//.origin(function(d) {return d; })
		.on("dragstart", dragstarted)
		.on("drag", dragged)
		.on("dragend", dragended);

	var zoom = d3.behavior.zoom()
		.scaleExtent([1, 10])
		.on("zoom.redraw", zoomed);

	var svg = d3.select("body").append("svg")
		.attr("width", width)
		.attr("height", height)
	//	.attr("class", "draggable")
	//.append("g")
		.call(zoom)
		//.call(drag);


	var g = svg.append("g");

	var worldGroup = g.append("g");
	var arcGroup = g.append('g');
	var bornGroup = g.append("g");
	var acquiredGroup = g.append("g");

	var imageGroup = g.append('g');
	var pointGroup = g.append('g');
	// Also, text needs to be added to the `g` group

	var places = {
	    GSFC: [-76.852587, 38.991621],
	    KSC: [-80.650813, 28.524963]
	    };

	var route = {
	  type: "LineString",
	  coordinates: [
	    places.GSFC,
	    places.KSC
	  ]
	};
	    
	var point = pointGroup.append("g")
	    .attr("class", "points")
	  .selectAll("g")
	    .data(d3.entries(places))
	  .enter().append("g")
	    .attr("transform", function(d) { return "translate(" + projection(d.value) + ")"; });

	point.append("text")
	    .attr("y", 5)
	    .attr("dx", "1em")
	    .text(function(d) { return d.key; });

	d3.json("data/world-110m2.json", function(error, world) {

		//draw the world
		worldGroup.append("g")
			.selectAll("path")
				.attr("id", "world")
				.data(topojson.feature(world, world.objects.countries).features)
			.enter().append("path")
				.attr("d", path);

		d3.csv("data/all_acquired.csv", function(error, data) {
			bornGroup.selectAll("circle")
				.data(data)
				.enter()
				//.append("a")
				//	.attr("xlink:href", function(d) {
				//		return "https://www.google.com/search?q=" + d.city;
				//	})
				.append("circle")
					.attr("cx", function(d) {
						return projection([d.birth_lon, d.birth_lat])[0];
					})
					.attr("cy", function(d) {
						return projection([d.birth_lon, d.birth_lat])[1];
					})
					.attr("r", 3)
					.style("fill", "red")
					.style("opacity", "0.2")
				.append("text")
					.text(function(d) { return d.name })

			acquiredGroup.selectAll("circle_end")
				.data(data)
				.enter()
				.append("circle")
					.attr("cx", function(d) {
						return projection([d.acquired_lon, d.acquired_lat])[0];
					})
					.attr("cy", function(d) {
						return projection([d.acquired_lon, d.acquired_lat])[1];
					})
					.attr("r", 3)
					.style("fill", "blue")
					.style("opacity", "0.2")
				.append("text")
					.text(function(d) { return d.name });

			var lineTransition = function lineTransition(path) {
				path.transition()
					// ms for line drawing speed
					.duration(5500)
					.attrTween("stroke-dasharray", tweenDash)
					.each("end", function(d, i){
						/// Uncomment to re-transition
						// d3.select(this).call(transition)
						
						// Do new stuff when line reaches target
						// doStuffWhenLineFinishes(d, i);
					});
			};
			var tweenDash = function tweenDash() {
				// Animate the dash-array property.
				// Gives anumation along some arbitrary path
				// Here, line moving from point A to B.
				var len = this.getTotalLength(),
					interpolate = d3.interpolateString("0," + len, len + "," + len);
				return function(t) { return interpolate(t); };
			};

			// -- Add paths
			// Format of object is an array of objects, each containin 
			// a type (LineString - the path will automatically draw a greatArc)
			// and coordinates
			var links = [
				{
					type: "LineString", 
						coordinates: [
							[data[0].birth_lon, data[0].birth_lat],
							[data[1].birth_lon, data[1].birth_lat]
						]
				}
			];

			//you can build links any way you want - e.g. if you have only
			// certain items you want to draw paths between
			// Alternatively, it can be created automatically based on the data
			links = [];
			for(var i=0, len=data.length-1; i<len; i++) {
				// (note: loop until length -1 since we're getting the next
				// item with i+1)

				links.push({
					type: "LineString",
					coordinates: [
						[data[i].birth_lon, data[i].birth_lat],
						[data[i+1].birth_lon, data[i+1].birth_lat]
					]
				});
			}

			//Standard enter/update
			var pathArcs = arcGroup.selectAll(".arc")
				.data(links);

			//enter
			pathArcs.enter()
				//.append("path").attr({
				//	"class", "arc"
				//})
				//.style({fill:"none"});
			
			//update
			pathArcs
				.attr({
				// d is the points attribute for this path, draw
				// an arc between the points using the arc function
				d:path})
				.style({stroke: "#0000ff", "stroke-width": "2px"})
				// Uncomment this line to remove the transition
				.call(lineTransition);
			pathArcs.exit().remove();
		});

	});	
	//Functions:

	function zoomed() {

		//d3.event.sourceEvent.preventDefault();

		g.attr("transform", "translate(" + 
			d3.event.translate.join(",") + ")scale(" + d3.event.scale + ")" );
		
		//g.selectAll("path")
		//	.attr("d", path.projection(projection));
	}

	function dragstarted(d) {
		d3.event.sourceEvent.stopPropagation();
		d3.select(this).classed("dragging", true);
	}

	function dragged() {
		var p = d3.mouse(this);
		projection.rotate( [ λ( p[0] ), φ( p[1]) ] );
		svg.selectAll("path").attr("d", path);		
	}

	function dragended(d) {
		d3.select(this).classed("dragging", false)
	}

//var xy = mercator([longitude, latitude]);

svg.append("path")
    .datum({type: "LineString", coordinates: [[-77.05, 38.91], [116.35, 39.91]]})
    .attr("class", "arc")
    .attr("d", path);

	</script>

</body>
